## 分布式数据库

单库：查询慢优化思路：1.建立索引 2.优化sql语句 3.加缓存

数据库层面，可以读写分离，一主多从，读可以搞个集群。 

为什么写不能搞集群？因为写集群要保证一致性，每台机子之间要同步，同步自身产生并发性，响应时间变短（处理时间+同步时间）导致并发降低等；所以写不太适合搞集群。

要提高写的并发性，要分库分表；由几个库共同承担并发压力，也不用考虑数据一致性问题。

mysql索引优化

1. 索引覆盖
   1. using index condition，虽然查找走了索引，但是还是要回表
   2. using where, using index 表示没有回表

分布式数据库 是指 使用分库分表和读写分离的数据库集群。

技术难度：

- 跨库无法join，只能通过接口
- 分布式事务
- 排序、分组、合并、分页

数据库中间件两种模式：

- 客户端模式（集成到java项目中) 比如sharding-jdbc  ：由于数据整合需要大量内存空间，不适合海量数据场景，适合高并发场景
- 服务端代理模式 比如mycat:对客户端通明

mycat

1. 为什么要分库分表  数据复制（读写分离）只能提高数据读并发操作能力，并不能提高数据写操作并发的能力以及数据整个的存储容量，也就是并不能提高数据库总存储记录数。如果我们数据库的写操作也有大量的并发请求需要满足，或者是我们的数据表特别大，单一的
2. 垂直拆分、水平拆分的区别
3. 怎么垂直拆分
   1. 微应用，已经天然实现了垂直拆分，不同微服务，不同数据库
   2. 如果一张表过大，拆分成两张表 也是垂直拆分
4. 怎么水平拆分
   1. 拆分字段， 单个字段，组合字段 （生成一个专门的partitionId)
   2. 拆分算法   范围分区、枚举分区（列表分区）、散列分区
   3. 水平扩充
   4. 拆分规则抽象好，join操作基本可以数据库做；但是很难；全局表（每个库都有一份）就是为了解决跨库join，但是全局表的更新会引入跨库事务或者引入主从，mycat不保证一致性
   5. 跨库事务
5. 什么是mycat，实现分库分表、读写分离 （主从复制还是需要mysql本身）



分表一定提升效率么？查询必须带where 分片字段；如果把每个sql都发送到不同的库，由mycat聚合，效率就会慢。

主从复制原理：

主库写入binlog, 从库从网络io写入relay-log，再导入mysql

主从模式：1主1从，1主多从，主<->主，多主一从，级联 主->从->从->从->从

## Mycat

### log/wrapper.log

日志文件

### schema.xml

逻辑库、逻辑表、分片规则（路由规则）

```
<schema name="TESTDB" >
<table name="company" dataNode="dn1,dn2,dn3" rule="mod-long"/>
<dataNode>
<dataHost>
   <writeHost>
      <readHost/>
      </writeHost>
    <writeHost/>

要求dn1,dn2,dn3必须有company这张表，每个数据节点可以当作一个分片库，可以读写分离；
```



逻辑表分为 

分片表、

ER表、父子表 统一解决跨库join问题 或者采用统一的分片规则 childTable 可以根据父表的路由规则计算出路由到哪个库。

全局表（所有库里的数据一样），为了便于join查询，冗余存放；比如insert语句会往所有node分发

非分片表 只需定义一个数据节点



数据节点  数据主机  一个数据节点对应一个数据库， 数据主机是数据节点存方的物理地址，包含写主机、读主机。

### dataHost

每个数据主机可以是一个主从集群：

 负载均衡类型：balance 属性,一般使用1或3

（1）balance="0", 不开启读写分离机制，所有读操作都发送到当前可用的writeHost 上。

（2）balance="1"，全部的 readHost 与 stand by writeHost 参与 select 语句的负载均衡，简单的说，当双主双从模式(M1->S1，M2->S2，并且 M1 与 M2 互为主备)，正常情况下，M2,S1,S2 都参与 select 语句的负载均衡。

（3）balance="2"，所有读操作都随机的在 writeHost、 readhost 上分发。

（4）balance="3"，所有读请求随机的分发到 wiriterHost 对应的 readhost 执行，writerHost 不负担读压力，注意 balance=3 只在 1.4 及其以后版本有，1.3 没有

**加上了事务以后(只读事务也是事务),MYCAT ,就一定会去查询写库.**

writeType 属性  （双主，互为主备）

（1）writeType="0", 所有写操作发送到配置的第一个 writeHost，第一个挂了切到还生存的第二个riteHost，重新启动后已切换后的为准，切换记录在配置文件中:dnindex.properties.

（2）writeType="1"，所有写操作都随机的发送到配置的 writeHost，1.5 以后废弃不推荐。

### server.xml

配置user;端口

配置序列号方式：1）文件 2）数据库 3）18位时间戳 类似雪花算法   

雪花算法：

- **1bit**，不用，因为二进制中最高位是符号位，1表示负数，0表示正数
- **41bit-时间戳**，用来记录时间戳，毫秒级 只能使用到2039.9.7
- **10bit-工作机器id**
- **12bit-序列号**，序列号，用来记录同毫秒内产生的不同id。 实现思路 每一毫秒重置为1，获取的时候判断是否已超过1s，超过1s重置为1；

4）一致型哈希

哈希是什么？哈希是算法总称；将任意长度的输入转换成固定长度的输出

常见的哈希算法：平方取中，取模，截取。

分布式缓存，如果采用普通哈希取模，当扩容的时候，造成缓存穿透，即雪崩。

### rule.xml

枚举路由规则，比如省份

取模路由规则

范围 比如0-500M=1 500M-1000M=2

一些问题:批量插入回滚，分布式事务

